#include "main_code.hpp"

/**
 * @brief Конструктор класса RabinKarpSearcher.
 *
 * Инициализирует основные данные: текст и шаблон.
 *
 * @param text Текст, в котором будет производиться поиск.
 * @param pattern Шаблон, который нужно найти в тексте.
 */
RabinKarpSearcher::RabinKarpSearcher(const string& text, const string& pattern)
    : text_(text), pattern_(pattern) {}

/**
 * @brief Поиск всех вхождений шаблона в текст с использованием алгоритма Рабина-Карпа.
 *
 * Алгоритм Рабина-Карпа использует хэширование для ускорения поиска подстрок. В начале
 * вычисляются хэш-коды для шаблона и первых подстрок текста. Затем метод скользит по тексту
 * с обновлением хэш-кода и проверкой совпадений.
 *
 * @return vector<int> Вектор, содержащий индексы всех вхождений шаблона в текст.
 */
vector<int> RabinKarpSearcher::search() {
    vector<int> positions;
    
    long m = pattern_.length(); ///< Длина шаблона.
    long n = text_.length(); ///< Длина текста.
    int p = 0; ///< Хэш-код для шаблона.
    int t = 0; ///< Хэш-код для текущей подстроки текста.
    int h = 1; ///< Коэффициент для вычисления хэш-кодов с учетом сдвигов.

    /**
     * @brief Вычисление коэффициента h для хэширования.
     *
     * Переменная h используется для вычисления хэш-кодов с учетом сдвигов символов в строках.
     * Это предвычисленный множитель, который используется в дальнейшем для обновления хэш-кодов.
     *
     * d — основание системы счисления, q — модуль для хэширования.
     */
    for (int i = 0; i < m - 1; i++) {
        h = (h * d) % q;
    }

    //! Вычисляем хэш-коды для шаблона и первой подстроки текста.
    for (int i = 0; i < m; i++) {
        p = (d * p + pattern_[i]) % q; ///< Хэш-код для шаблона.
        t = (d * t + text_[i]) % q; ///< Хэш-код для первой подстроки текста.
    }

    //! Основной цикл поиска.
    for (int i = 0; i <= n - m; i++) {
        if (p == t) {
            int j = 0;
            while (j < m && text_[i + j] == pattern_[j]) {
                j++;
            }
            if (j == m) {
                positions.push_back(i); ///< Записываем индекс вхождения шаблона.
            }
        }

        //! Обновление хэш-кода для следующей подстроки текста.
        if (i < n - m) {
            t = (d * (t - text_[i] * h) + text_[i + m]) % q;
            if (t < 0) {
                t = (t + q); ///< Корректировка для отрицательных значений.
            }
        }
    }
    
    return positions;
}


/**
 * @brief Метод для чтения содержимого файла.
 *
 * Метод открывает файл с указанным именем и читает его содержимое. Если файл не удается
 * открыть, возвращается пустая строка, а в консоль выводится сообщение об ошибке.
 *
 * @param filename Имя файла для чтения.
 * @return string Содержимое файла в виде строки.
 */
string FileManager::readFile(const string& filename) {
    ifstream file(filename);
    if (!file) {
        cerr << "Не удалось открыть файл: " << filename << endl;
        return "";
    }
    return string((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
}

